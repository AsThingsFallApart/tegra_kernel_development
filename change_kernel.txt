# Change the kernel on a Jetson Orin Nano Devkit using an x86_64 host, beginning to end.

Requirements
============================================================
1. a machine with a Linux operating system
	- NVIDIA recommends Ubuntu 22.04 LTS



Procedure
============================================================
1. Download
2. Configure
3. Make
4. Flash
5. Verify



1. Download
============================================================
see:
- https://developer.nvidia.com/embedded/jetson-linux-r363

	a. download "Driver Package (BSP)" in "DRIVERS"

	b. download "Sample Root Filesystem" in "DRIVERS"

	c. download "Bootlin Toolchain gcc 11.3" in "TOOLS"



2. Configure
============================================================
see: 
- https://docs.nvidia.com/jetson/archives/r36.3/DeveloperGuide/IN/QuickStart.html#to-flash-the-jetson-developer-kit-operating-software

	- the following commands assume the working (current) directory is the directory that was generated by git clone: "tegra_kernel_development"

	a. run "tar xvf ${DEFAULT_DOWNLOAD_DIRECTORY}/${L4T_RELEASE_PACKAGE}"

		i. where `DEFAULT_DOWNLOAD_DIRECTORY` is either the home path ("~") or the Downloads directory (path "~/Downloads")
		ii. where `L4T_RELEASE_PACKAGE` is like "Jetson_Linux_R36.3.0_aarch64.tbz2"
		iii. this command sets up the parent directory containing all the files relevant to building the tegra kernel
		

		iv. tip: as you type out a command, press 'tab' in BASH (default Ubuntu shell) to autocomplete or show possible autocompletions when there is more than one possible match
		v. tip: press 'UpArrow' in BASH to pull the last command from history

	b. run "sudo tar xvfp ${DEFAULT_DOWNLOAD_DIRECTORY}/${SAMPLE_FS_PACKAGE} -C Linux_for_Tegra/rootfs/" 

		i. where `SAMPLE_FS_PACKAGE` is like "Tegra_Linux_Sample-Root-Filesystem_R36.3.0_aarch64.tbz2".
		ii. understand: as seen in the verbose output of the last command (tar xvf ${L4T_RELEASE_PACKAGE}), `L4T_RELEASE_PACKAGE` is an archive that contains compressed files. The command "tar" decompresses all these files and subdirectories into uncompressed forms. Command "tar" also accepts "switches" denoted by the "-${X}" ("dash x") syntax where X is some letter. Switches are convenient ways to enable features of a command. Each x, v, f, and p in "tar xvfp" are also switches but as a special tar syntax. Developers will often provide a "--help" switch to learn more their command
		iii. this command sets up the file hierarchy of the root filesystem that will be used on the Jetson
		iv. "sudo" is short for "Superuser do"
		v. sudo bestows access the the root filesystem. Use your imagination to figure out why the original Unix developers wanted to block arbitrary code from changing these files that contain kernel objects and operating system binaries 


	c. run "cd Linux_for_Tegra"

		i. "cd" is short for "Change Directory"


	d. run "ls -la"

		i. command "ls" is short for "list". Feel free to take a look around
		ii. the "-a" switch, short for "all", instructs command "ls" to print hidden files.
		iii. the "-l" switch, short for "long", instructs command "ls" not only print more file attributes but also format in columns


	d. run "sudo ./tools/l4t_flash_prerequisites.sh"

		iii. this script will use Ubuntu's package manager "APT" to download necessary dependencies for building and flashing


	e. run "sudo ./apply_binaries.sh"

		i. this script is necessary for for the success of the entire process; this script will also break because it uses some old Debian commands like "install".
		ii. to fix, read the errors produced: they will be similar to "qemu failed with error message 11" or "dpkg failed to (--install) libc-bin"
		iii. keep executing the script until you see something like "error: /Linux_for_Tegra/rootfs/dev/bin/random already exists"
		iv. delete file "random" by running "sudo rm rootfs/dev/bin/random". Command "rm" is short for "remove".
		v. the script will also create another file in the same directory called "urandom". Run "sudo rm rootfs/dev/bin/urandom"
		vi. keep trying to execute the script and deleting these files until "Success!" is printed in the terminal after lots of downloading. 



3. Make
============================================================
see:
- https://docs.nvidia.com/jetson/archives/r36.3/DeveloperGuide/AT/JetsonLinuxToolchain.html#at-jetsonlinuxtoolchain

	a. run "mkdir $HOME/l4t-gcc"

		i. command "mkdir" is short for "Make Directory".
		ii. the syntax "$HOME" ("dollar sign home") is an Environment Variable. Environment variables are bindings (generally, setting one thing to another). You can tell a word is referencing an environment variable if there is a dollar sign directly in front of it. Developers also generally follow the pattern of casing environment variables in all capital letters even though there is no system that enforces this pattern. The command "env" prints all the environment variables that have been set in your shell.


	b. run "tar xvf ~/${TOOLCHAIN_COMPRESSED_FILES}"

		i. where `TOOLCHAIN_COMPRESSED_FILES` is like "aarch64--glibc--stable-2022.08-1.tar.bz2"
		ii. this will create a directory with the same name in your home directory.


	c. run "mv ~/${TOOLCHAIN_DECOMPRESSED_FILES}/* ~/l4t-gcc/"

		i. where `TOOLCHAIN_DECOMPRESSED_FILES` is like `TOOLCHAIN_COMPRESSED_FILES` but a directory file instead of a tarball file.
		ii. command "mv" is short for "Move".
		iii. the wildcard "*" ("star") will match the file name of every file in directory `TOOLCHAIN_DECOMPRESSED_FILES` and move them into directory at path "~/l4t-gcc/"

		
	d. run "ls -la ~/${TOOLCHAIN_DECOMPRESSED_FILES}"

		i. there should be two files in the directory now: "." and "..".
		ii. these hidden files can be found in every directory and are used as quickhands for "here" (.) and "the directory before" (..).


	e. run "rm -r ~/${TOOLCHAIN_DECOMPRESSED_FILES}"

		i. since the directory is now empty, get rid of it.
		ii. now the tools necessary to compile the kernel are available. Generally, the collection of tools necessary to enable a workflow is called a "toolchain".


see:
- https://docs.nvidia.com/jetson/archives/r36.3/DeveloperGuide/SD/Kernel/KernelCustomization.html

	a. run "sudo apt install git-core build-essential bc"

		i. Use the APT to install the following packages "git-core", "build-essential", and "bc".


	b. run "cd ${HOME_TO_PROJECT}/Linux_for_Tegra/source"

		i. where `HOME_TO_PROJECT` is a path from the home directory (~) to wherever the "tegra_kernel_development" directory was cloned.


	c. run "./source_sync.sh -k -t ${RELEASE_TAG}"

		i. where `RELEASE_TAG` is like "jetson_36.3"
		ii. see: https://docs.nvidia.com/jetson/archives/r36.3/ReleaseNotes/Jetson_Linux_Release_Notes_r36.3.pdf
		iii. get a snack, this will take longer than compiling a rust project
		iv. after the script is done, the BASH prompt will be returned, and all the kernel source files will be at path "${HOME_TO_PROJECT}/Linux_for_Tegra/source/kernel/kernel-jammy-src"

	
	d. run "cp ../../helloworld.c kernel/kernel-jammy-src/drivers/media/i2c/"

		i. command "cp" is short for "copy"
		ii. the parameters (things that come after the command that don't have dashes infront of them like switches) are paths.
		iii. in english: copy the file "helloworld.c" found at path "../../" to directory "i2c" found at path "kernel/kernel-jammy-src/drivers/media/i2c/" and name it the same
		iv. this puts file `helloworld.c` inside the kernel source directory

	
	e. use your favorite text editor to open file `Makefile` at path "./kernel/kernel-jammy-src/drivers/media/i2c/Makefile"


	f. add the line "obj-$(CONFIG_HELLOWORLD) += helloworld.o"

		i. the make program now knows to include "helloworld.c" as a "module" when compiling; more on this later

	
	g. use your favorite text editor to open file `Kconfig` at path "./kernel/kernel-jammy-src/drivers/media/i2c/Kconfig"


	h. add the following block anywhere in file `Kconfig`:
	"
	config HELLOWORLD
		tristate "in-tree module test"
		default y
		help
		  This is a test module designed to exemplify how a module is compiled
		  with the kernel in-tree.

		  To compile this driver as a module, choose M here: the
		  module will be called helloworld.
	"

		i. file `Kconfig` is used by the make system to enumerate kernel features
		ii. choosing which drivers are included the final `Image` file that results from compiling the kernel comes from the kernel configuration file (`.config`)
		iii. as a consequence, a driver can be inside the kernel source and not be included in the final `Image` file if it isn`t enabled in the kernel configuration file

	
	i. run "export ARCH=arm64"
		
		i. "arm64" is a synonym for ARM 64-bit architecture's official name "aarch64"
		ii. customizing the configuration in the next step relies on this environment variable to know which architecture the configuration is targeting
		iii. by default ARCH=x86_64 which is not the same architecture the Jetson module was built with


	j. run "cd ${HOME_TO_PROJECT}/tegra_kernel_development/Linux_for_Tegra/source/kernel/kernel-jammy-src"


	k. run "make menuconfig"

		i. look at the top left of the shell: assert the line matches ".config - Linux/arm64 5.15.136 Kernel Configuration"
		ii. press '/'
		iii. type "helloworld"
		iv. press 'Enter'
		v. the block added to the `Kconfig` file should be found; take note of its location
		vi. press 'Enter'
		vii. press 'd'
		viii. press 'DownArrow' until "<M> Multimedia support  --->" is hovered
		viv. press 'Enter'
		x. press 'e' four times
		xi. press 'Enter'
		xii. press 'c'
		xiii. press 'Enter'
		xiv. notice: the line "<M> in-tree module test"; the configuration exists and is enabled as a module
		xv. press 'Escape'
		xvi. press 'RightArrow' three times
		xvii. press 'Enter'
		xviii. press 'Enter'
		xix. press 'Escape' until back in the command line


	l. run "vi .config"
		
		i. press '/' to search
		ii. type "HELLOWORLD"
		iii. press 'Enter'
		iv. notice: the configuration was successfully written to file `.config` and includes the new driver file
		v. press ':'
		vi. press 'q'
		vii. press 'Enter' to exit vi


	m. run "export CROSS_COMPILE=~/l4t-gcc/bin/aarch64-buildroot-linux-gnu-"

		i. command "export" creates an environment variable in the current shell instance. This means closing the terminal window will wipe this environment variable and it will have to be re-exported.
		ii. the environment variable created is given the identifier "CROSS_COMPILE" by typing the desired name immediately after the command. This name is significant since the compilation tools are hard-coded to query an environment variable with the name "CROSS_COMPILE".


	n. run "echo $CROSS_COMPILE"

		i. command "echo" will print info to terminal
		ii. the desired output is "/home/${YOU!}/l4t-gcc/bin/aarch64-buildroot-linux-gnu-", the value just set to environment variable "CROSS_COMPILE"
		iii. obviously this is not necessary, unless sanity is counted as necessary.


	o. run "make -C kernel"

		i. the tegra kernel, based off the Linux kernel, is a make project. Make is a system for compiling projects that involve more than one source file. It enables project-wide compilation only for source files that haven't been compiled or changed before. Systems would be impossible to scale without a compilation-manager like make since seeing the effect of a code change, for example, would involve waiting not just for the one changed file to compile but for all files to compile.
		ii. which files make compiles is not chosen automatically: developers have to explicitally state which files are compiled in files called "Makefiles"
		iii. thankfully, NVIDIA provides a nice Makefile that denotes which types of objects are compiled from their respective source files, which directories to change to, and make switches for automatic utilization of nearly 100% of the CPU.
		iv. press the "meta" key (usually the windows key or Mac's option key), type "system", and press enter on "system monitor" to view how make is using the host machine's resources
		v. the `.config` file generated earlier tells the make program to include `helloworld.o` in the final kernel image


	p. run "export INSTALL_MOD_PATH=${HOME_TO_PROJECT}/tegra_kernel_development/Linux_for_Tegra/rootfs/"

		i. this command exports an environment variable "INSTALL_MOD_PATH" that NVIDIA uses to find the root file system to be flashed


	q. run "sudo -E make install -C kernel"

		i. there are a couple of new things here: the "-E" switch tells commmand "sudo" to preserve the environment if the security policy allows. this allows CROSS_COMPILE and INSTALL_MOD_PATH to be used to change root-level files in command "make install"
		ii. the "-C" switch for command "make install" tells the make program to change to the directory "kernel" before following instructions inscribed in that directory's Makefile.


	r. run "cp kernel/kernel-jammy-src/arch/arm64/boot/Image ../kernel/Image"


	s. run "export KERNEL_HEADERS=$PWD/kernel/kernel-jammy-src"


	t. run "make modules"


	u. run "sudo -E make modules_install"

		i. the NVIDIA engineers decided not to include a warm, fuzzy "modules installed successfully" feedback at the end of this command.
		ii. it's ok, the script did everything it is supposed to do.


	v. run "cd .."


	x. run "sudo ./tools/l4t_update_initrd.sh"

		i. this command calls a binary named "nv-update-initrd" that was installed during Configure, step e: "sudo ./apply_binaries.sh"
		ii. thankfully, this script has a warm fuzzy at the end. Everything in life is in order.


	y. run "cd source"


	z. run "make dtbs"

		i. "dtbs" is short for "device tree blobs"
		ii. the device tree enables lightweight hardware discovery by denoting memory addresses and other metadata of all hardware in an embedded device


	aa. run "cp nvidia-oot/device-tree/platform/generic-dts/dtbs/* ../kernel/dtb/"

		i. this command globs (matches) everything in the directory "dtbs" at path "./nvidia-oot/device-tree/platform/generic-dts/dtbs/" and copies it to directory "dtb" at path "~/Linux_for_Tegra/kernel/dtb/".
		ii. "oot" is short for "out of tree". Out of tree kernel modules are not baked-in the tegra kernel like "in-tree" modules. That is, they can be attached and removed after the kernel is booted. Since they are not bundled with the kernel, they do not add to the size of the final "Image" file.


	ab. run "cd ${HOME_TO_PROECT}/tegra_kernel_development/Linux_for_Tegra/rootfs/lib/modules/5.15.136-tegra/kernel/drivers/media/i2c"
		i. this directory is where the multimedia, i2c drivers are
		ii. since this directory is a subdirectory of `rootfs`, and `rootfs` will be copied from host to to the Jetson module, everything in this directory will be present on the Jetson Linux immediately after flashing


	ac. run "ls -la"
		i. kernel object `helloworld.ko` should exist
		ii. if `helloworld.ko` is not here, copy `helloworld.c` to path "${HOME_TO_PROJECT}/tegra_kernel_development/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/media/i2c/", edit the `Makefile` in the same directory to include the line "obj-$(CONFIG_HELLOWORLD) += helloworld.o", use your favorite text editor to add the following block anywhere in the `Kconfig` file in the same directory:
		"
			config HELLOWORLD
			tristate "in-tree module test"
			default y
			help
			  This is a test module designed to exemplify how a module is compiled
			  with the kernel in-tree.

			  To compile this driver as a module, choose M here: the
			  module will be called helloworld.
		",
		run command "ARCH=arm64 make menuconfig", change nothing, save, make again, install again, and check the `rootfs` directory again (steps Make, d through r).



4. Flash
============================================================
see:
- https://docs.nvidia.com/jetson/archives/r36.3/DeveloperGuide/IN/QuickStart.html#to-flash-the-jetson-developer-kit-operating-software

	a. assert an microSD card with atleast 64 gigabytes of memory is inserted into the jetson's microSD card port

		i. on the devkit, the microSD card port is under the jetson module
		ii. the port is invisible from top-down, pick up the devkit and look under the jetson module from the long side to see it.
		iii. it is above the pins "LED -", "LED +", "UART RXD", "UART TXD", and "DIS"

	a (alternate: use NVMe). assert an NVMe with atleast 64 gigabytes of memory is inserted into the long M.2 slot under the devkit


	b. assert the jetson is in "recovery mode"

		i. recovery mode is set by shorting the "FC REC" pin.
		ii. On the devkit, the "FC REC" pin is located under the jetson module which is located under the fan.
		iii. Short FC REC by taking a jumper cable and attaching one end to FC REC and another end to any pin labled "GND" (ground).


	c. assert the jetson devkit is connected to the host machine

		i. a USB-C (Jetson-side) to USB-A (host machine-side) would work


	d. assert the barrel power cable is disconnected

		i. the power LED near the USB-C port should be off.


	e. plug in the barrel power cable

		i. the power LED should emit green
		ii. if a display port cable is plugged in and connected to a monitor, nothing should show up
		iii. the jetson module is waiting for commands


	f. run "cd ${HOME_TO_PROJECT}/Linux_for_Tegra"


	g. run "sudo ./tools/kernel_flash/l4t_initrd_flash.sh --external-device mmcblk0p1 -c tools/kernel_flash/flash_l4t_t234_nvme.xml -p "-c bootloader/generic/cfg/flash_t234_qspi.xml" --showlogs --network usb0 jetson-orin-nano-devkit internal

		i. this command will take up to ten minutes.
		ii. as seen in the verbose output, it handles operations like generating files from path "~/Linux_for_Tegra/rootfs" and transferring them from host machine to target (Jetson) via Network File System (NFS)
		iii. it is at this point where many uncaught bugs will result in bizzare hangs; read error messages and assert you have the most up-to-date documentation to debug.
		iv. if successful, the jetson will reboot itself despite being in recovery mode. The system then prompts to accept the NVIDIA Software License Agreement for Tegra Linux.


	g (alternate: use NVMe). run "sudo ./tools/kernel_flash/l4t_initrd_flash.sh --external-device nvme0n1p1 -c tools/kernel_flash/flash_l4t_t234_nvme.xml -p "-c bootloader/generic/cfg/flash_t234_qspi.xml" --showlogs --network usb0 jetson-orin-nano-devkit internal"

		i. notice the difference: mmcblk0p1 -> nvme0n1p1



5. Verify 
============================================================
	a. go through system configuration and pick your preferences

		i. Jetson Linux will restart to apply changes

	
	b. press 'ctrl' + 'alt' + 't' to quickly open a BASH

	
	c. run "cd /lib/modules/5.15.136-tegra/kernel/drivers/media/i2c"


	d. run "ls -la"
		
		i. verify that `helloworld.ko` exists on Jetson Linux


	e. run "sudo dmesg"
		
		i. command "dmesg" is short for "diagnostic messages"
		ii. when kernel driver developers want to print something, it prints to this message buffer
		iii. feel free to explore what happened from second 0 to present
	
	f. run "sudo modprobe helloworld"

		i. command "modprobe" adds and removes modules from the kernel
		

	g. run "sudo dmesg"

		i. the latest message in the buffer should be "helloworld: Hello world initialization!"


	h. run "sudo modprobe -r helloworld"
		
		i. switch "-r" for command "modprobe" changes modprobe's behavior to remove modules instead of add them


	i. run "sudo dmesg"

		i. the latest message in the buffer should be "helloworld: Hello world exit!"



You have successfully made and flashed a custom kernel to a Jetson Orin Nano Devkit
